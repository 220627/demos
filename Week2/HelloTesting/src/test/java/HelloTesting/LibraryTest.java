/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package HelloTesting;

import org.junit.Test;

import com.revature.Calculator;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;

//This is a test class! It'll be full of methods that test our Calculator Class
public class LibraryTest {

	//declare an uninitialized Calculator object so we can use and test its methods
	//I will instantiate and nullify it in @before and @after methods
	static Calculator calc;
	
	@BeforeClass //in JUnit 4, @BeforeClass makes a method run BEFORE any tests run
	//In JUnit 5, you can use @BeforeAll
	public static void initialize() {
		System.out.println("In the @BeforeClass method");
		calc = new Calculator();
	}
	
	@AfterClass //in JUnit 4, @AfterClass makes a method run AFTER all tests run
	//In JUnit 5, you can use @AfterAll
	public static void uninitialize() {
		System.out.println("In the @AfterClass method");
		calc = null;
	}
	
	//Why are we bothering to initialize and uninitialize calc? Memory saving basically.
	//But mostly as a reason to show @BeforeClass and @AfterClass lol
	
	//unit tests below---------------------------------------------
	
	@Test
	public void testAddition() {
		System.out.println("TESTING ADD METHOD");
		int result = calc.add(5, 15);
		assertTrue(result == 20);
	}
	
	@Test
	public void testSubtraction() {
		System.out.println("TESTING SUBTRACT METHOD");
		int result = calc.subtract(20, 5);
		assertEquals(15, result);
	}
	
	//Above are two POSITIVE TESTS - which are tests that take in valid input and test for valid output
	
	//below is a NEGATIVE TEST - which takes in invalid/erroneous input and tests for appropriate output
	
	@Test(expected = ArithmeticException.class) //we expect this method to throw an ArithmeticException.
	public void testZeroDivision() {
		System.out.println("TESTING DIVIDE BY ZERO");
		calc.divide(5, 0);
	}
	
	/*
	  in JUnit 5, we would use:
	  assertThrows(ArithmeticException.class, () -> {calc.divide(5, 0);});

	  INSTEAD of expected = ArithmeticException.class
	 */
	
}
